<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="{{ csrf_token }}">
    <title>Браки — Мобильная версия</title>
    <!-- Tailwind CSS -->
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Alpine.js -->
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <style>
        body { font-family: system-ui, -apple-system, sans-serif; }
        [x-cloak] { display: none !important; }
    </style>
</head>
<body class="min-h-screen bg-gray-50">
    <!-- Header -->
    <header class="bg-white border-b border-gray-200 py-4 fixed top-0 left-0 right-0 z-30">
        <div class="flex items-center justify-between px-4">
            <div class="flex items-center space-x-2">
                <div class="w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center">
                    <span class="text-white font-bold text-sm">S</span>
                </div>
                <span class="text-lg font-semibold text-gray-900">Smart Factory</span>
            </div>
            <div class="flex items-center space-x-3">
                <a href="/notifications/" class="text-gray-600 hover:text-gray-900">
                    <i data-lucide="bell" class="w-5 h-5"></i>
                </a>
                <a href="/settings/" class="text-gray-600 hover:text-gray-900">
                    <i data-lucide="settings" class="w-5 h-5"></i>
                </a>
        </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="pt-20 pb-20 px-4" x-data="defectsData()" x-init="init()">
        <!-- Заголовок -->
        <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-4 mb-4">
            <h1 class="text-xl font-bold text-gray-900 mb-2">Браки (дефекты)</h1>
            <p class="text-gray-600 text-sm">Система управления браками с подтверждением мастера</p>
            </div>
        
        <!-- Поиск -->
        <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-4 mb-4">
            <input type="text" placeholder="Поиск по продукту или сотруднику..." x-model="searchTerm"
                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
        
        <!-- Статистика -->
        <div class="grid grid-cols-2 gap-3 mb-4">
            <div class="bg-red-50 rounded-lg p-3">
                <p class="text-xs text-red-600">Всего браков</p>
                <p class="text-lg font-bold text-red-900" x-text="stats().totalDefects || 0"></p>
            </div>
            <div class="bg-yellow-50 rounded-lg p-3">
                <p class="text-xs text-yellow-600">Ожидают подтверждения</p>
                <p class="text-lg font-bold text-yellow-900" x-text="stats().pendingConfirmation || 0"></p>
            </div>
            <div class="bg-blue-50 rounded-lg p-3">
                <p class="text-xs text-blue-600">Можно починить</p>
                <p class="text-lg font-bold text-blue-900" x-text="stats().repairable || 0"></p>
            </div>
            <div class="bg-green-50 rounded-lg p-3">
                <p class="text-xs text-green-600">Починено</p>
                <p class="text-lg font-bold text-green-900" x-text="stats().repaired || 0"></p>
            </div>
        </div>
        
        <!-- Список браков -->
        <div class="space-y-3">
            <template x-for="defect in filteredDefects()" :key="defect.id">
                <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
                    <div class="flex justify-between items-start mb-2">
                        <div class="flex-1">
                            <h3 class="font-semibold text-gray-900" x-text="defect.product && defect.product.name ? defect.product.name : 'Неизвестный продукт'"></h3>
                            <p class="text-sm text-gray-600" x-text="defect.user && defect.user.full_name ? defect.user.full_name : 'Неизвестный сотрудник'"></p>
                        </div>
                        <span class="px-2 py-1 text-xs rounded-full" :class="getStatusClass(defect.status)">
                            <span x-text="defect.status_display || 'Неизвестный статус'"></span>
                        </span>
                    </div>
                    
                    <div class="flex items-center justify-between text-sm text-gray-500 mb-3">
                        <span x-text="formatDate(defect.created_at)"></span>
                        <span x-show="defect.defect_type" 
                              class="px-2 py-1 text-xs rounded-full"
                              :class="getDefectTypeClass(defect.defect_type)"
                              x-text="defect.defect_type_display || 'Неизвестный тип'"></span>
                    </div>
                    
                    <!-- Действия -->
                    <div class="flex space-x-2">
                        <button x-show="canConfirmDefect(defect)" 
                                @click="openConfirmationModal(defect)"
                                class="flex-1 px-3 py-2 bg-blue-600 text-white text-sm rounded hover:bg-blue-700">
                            Подтвердить
                        </button>
                        <button x-show="canMarkRepaired(defect)"
                                @click="openRepairModal(defect)"
                                class="flex-1 px-3 py-2 bg-green-600 text-white text-sm rounded hover:bg-green-700">
                            Починен
                        </button>
                        <button x-show="canCloseDefect(defect)"
                                @click="closeDefect(defect)"
                                class="flex-1 px-3 py-2 bg-gray-600 text-white text-sm rounded hover:bg-gray-700">
                            Закрыть
                        </button>
                    </div>
                </div>
            </template>
        </div>
        
        <!-- Пустое состояние -->
        <div x-show="filteredDefects().length === 0" class="text-center py-12">
            <i data-lucide="alert-triangle" class="mx-auto text-gray-400 mb-4" style="width: 48px; height: 48px;"></i>
            <p class="text-gray-500 text-lg" x-text="searchTerm ? 'Браки не найдены по вашему запросу' : 'Браки не найдены'"></p>
            <p x-show="searchTerm" class="text-gray-400 text-sm mt-2">Попробуйте изменить поисковый запрос</p>
        </div>
    </main>

    <!-- Модальное окно подтверждения брака -->
    <div x-show="showConfirmationModal === true" 
         x-cloak
         class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"
         x-transition:enter="transition ease-out duration-300"
         x-transition:enter-start="opacity-0"
         x-transition:enter-end="opacity-100"
         x-transition:leave="transition ease-in duration-200"
         x-transition:leave-start="opacity-100"
         x-transition:leave-end="opacity-0">
        <div class="bg-white rounded-lg p-4 w-full max-w-sm" @click.away="closeConfirmationModal()">
            <h3 class="text-lg font-semibold mb-4">Подтверждение брака</h3>
            
            <!-- Шаг 1: Подтверждение проверки -->
            <div x-show="confirmationStep === 1">
                <p class="text-gray-600 mb-4 text-sm">Вы подтверждаете, что подошли и тщательно проверили брак?</p>
                <div class="space-y-2">
                    <button @click="confirmationStep = 2" 
                            class="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">
                        Да, подтверждаю
                    </button>
                    <button @click="closeConfirmationModal()" 
                            class="w-full px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400">
                        Отмена
                    </button>
                </div>
            </div>
            
            <!-- Шаг 2: Можно ли починить -->
            <div x-show="confirmationStep === 2">
                <p class="text-gray-600 mb-4 text-sm">Можно ли починить брак?</p>
                <div class="space-y-2">
                    <button @click="confirmationStep = 3; selectedDefect.is_repairable = true" 
                            class="w-full px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">
                        Да, можно починить
                    </button>
                    <button @click="confirmationStep = 4; selectedDefect.is_repairable = false" 
                            class="w-full px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700">
                        Нет, нельзя починить
                    </button>
                </div>
            </div>
            
            <!-- Шаг 3: Тип брака (если нельзя починить) -->
            <div x-show="confirmationStep === 4">
                <p class="text-gray-600 mb-4 text-sm">Выберите тип брака:</p>
                <div class="space-y-3 mb-4">
                    <label class="flex items-center">
                        <input type="radio" x-model="selectedDefect.defect_type" value="technical" class="mr-2">
                        <span class="text-sm">Технический (штраф не списывается)</span>
                    </label>
                    <label class="flex items-center">
                        <input type="radio" x-model="selectedDefect.defect_type" value="manual" class="mr-2">
                        <span class="text-sm">Ручной (штраф списывается с сотрудника)</span>
                    </label>
                </div>
                <div class="space-y-2">
                    <button @click="confirmationStep = 5" 
                            :disabled="!selectedDefect.defect_type"
                            class="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50">
                        Далее
                    </button>
                    <button @click="confirmationStep = 2" 
                            class="w-full px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400">
                        Назад
                    </button>
                </div>
            </div>
            
            <!-- Шаг 4: Выбор цеха для исправления -->
            <div x-show="confirmationStep === 5">
                <p class="text-gray-600 mb-4 text-sm">Выберите цех для исправления брака:</p>
                <select x-model="selectedDefect.target_workshop_id" class="w-full p-2 border border-gray-300 rounded mb-4">
                    <option value="">Выберите цех...</option>
                    <template x-for="workshop in workshops" :key="workshop.id">
                        <option :value="workshop.id" x-text="workshop.name || 'Неизвестный цех'"></option>
                    </template>
                </select>
                <div x-show="workshops.length === 0" class="text-red-500 text-sm mb-4">
                    Не удалось загрузить список цехов. Попробуйте обновить страницу.
                </div>
                <div class="space-y-2">
                    <button @click="confirmDefect()" 
                            :disabled="!selectedDefect.target_workshop_id || workshops.length === 0"
                            class="w-full px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:opacity-50">
                        Подтвердить
                    </button>
                    <button @click="confirmationStep = 4" 
                            class="w-full px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400">
                        Назад
                    </button>
                </div>
            </div>
            
            <!-- Шаг 5: Комментарий -->
            <div x-show="confirmationStep === 3">
                <p class="text-gray-600 mb-4 text-sm">Добавьте комментарий (необязательно):</p>
                <textarea x-model="selectedDefect.comment" 
                          placeholder="Комментарий мастера..."
                          class="w-full p-2 border border-gray-300 rounded mb-4 h-20 text-sm"
                          maxlength="500"></textarea>
                <div class="text-xs text-gray-500 mb-4">
                    <span x-text="(selectedDefect.comment || '').length"></span>/500 символов
                </div>
                <div class="space-y-2">
                    <button @click="confirmDefect()" 
                            class="w-full px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">
                        Подтвердить
                    </button>
                    <button @click="confirmationStep = 2" 
                            class="w-full px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400">
                        Назад
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно отметки починки -->
    <div x-show="showRepairModal === true" 
         x-cloak
         class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"
         x-transition:enter="transition ease-out duration-300"
         x-transition:enter-start="opacity-0"
         x-transition:enter-end="opacity-100"
         x-transition:leave="transition ease-in duration-200"
         x-transition:leave-start="opacity-100"
         x-transition:leave-end="opacity-0">
        <div class="bg-white rounded-lg p-4 w-full max-w-sm" @click.away="closeRepairModal()">
            <h3 class="text-lg font-semibold mb-4">Отметить брак как починенный</h3>
            <p class="text-gray-600 mb-4 text-sm">Добавьте комментарий по починке (необязательно):</p>
            <textarea x-model="repairComment" 
                      placeholder="Комментарий по починке..."
                      class="w-full p-2 border border-gray-300 rounded mb-4 h-20 text-sm"
                      maxlength="500"></textarea>
            <div class="text-xs text-gray-500 mb-4">
                <span x-text="(repairComment || '').length"></span>/500 символов
            </div>
            <div class="space-y-2">
                <button @click="markAsRepaired()" 
                        class="flex-1 px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">
                    Отметить как починенный
                </button>
                <button @click="closeRepairModal()" 
                        class="flex-1 px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400">
                    Отмена
                </button>
            </div>
        </div>
    </div>

    <!-- Нижняя навигация -->
    <nav class="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 px-4 py-2">
        <div class="flex justify-around">
            <a href="/dashboard/" class="flex flex-col items-center py-2 text-gray-600 hover:text-blue-600">
                <i data-lucide="home" class="w-5 h-5 mb-1"></i>
                <span class="text-xs">Главная</span>
            </a>
            <a href="/employees/" class="flex flex-col items-center py-2 text-gray-600 hover:text-blue-600">
                <i data-lucide="users" class="w-5 h-5 mb-1"></i>
                <span class="text-xs">Сотрудники</span>
            </a>
            <a href="/defects/" class="flex flex-col items-center py-2 text-red-600">
                <i data-lucide="alert-triangle" class="w-5 h-5 mb-1"></i>
                <span class="text-xs">Браки</span>
            </a>
            <a href="/inventory/" class="flex flex-col items-center py-2 text-gray-600 hover:text-blue-600">
                <i data-lucide="package" class="w-5 h-5 mb-1"></i>
                <span class="text-xs">Склад</span>
            </a>
        </div>
    </nav>

    <script>
    function defectsData() {
            return {
            defects: [],
            workshops: [],
                searchTerm: '',
            showConfirmationModal: false,
            showRepairModal: false,
            confirmationStep: 1,
            selectedDefect: {},
            repairComment: '',
            currentUser: null,
            
            async fetchDefects() {
                try {
                    const resp = await fetch('/defects/api/defects/');
                    if (resp.ok) {
                        const data = await resp.json();
                        // Проверяем структуру данных
                        if (data && Array.isArray(data)) {
                            this.defects = data;
                        } else if (data && data.results && Array.isArray(data.results)) {
                            this.defects = data.results;
                        } else {
                            console.warn('Неожиданная структура данных браков:', data);
                            this.defects = [];
                        }
                    } else {
                        console.warn('Не удалось загрузить браки:', resp.status);
                        this.defects = [];
                    }
                } catch (error) {
                    console.warn('Ошибка при загрузке браков:', error);
                    this.defects = [];
                }
            },
            
            async fetchWorkshops() {
                try {
                    const resp = await fetch('/workshops/api/workshops/');
                    if (resp.ok) {
                        const data = await resp.json();
                        // Проверяем структуру данных
                        if (data && Array.isArray(data)) {
                            this.workshops = data;
                        } else if (data && data.results && Array.isArray(data.results)) {
                            this.workshops = data.results;
                        } else {
                            console.warn('Неожиданная структура данных цехов:', data);
                            this.workshops = [];
                        }
                    } else {
                        console.warn('Не удалось загрузить цеха:', resp.status);
                        this.workshops = [];
                    }
                } catch (error) {
                    console.warn('Ошибка при загрузке цехов:', error);
                    this.workshops = [];
                }
            },
            
            async fetchCurrentUser() {
                try {
                    const resp = await fetch('/accounts/api/profile/');
                    if (resp.ok) {
                        const data = await resp.json();
                        // Проверяем структуру данных
                        if (data && typeof data === 'object') {
                            this.currentUser = data;
                        } else {
                            console.warn('Неожиданная структура данных пользователя:', data);
                            this.currentUser = null;
                        }
                    } else {
                        console.warn('Не удалось загрузить пользователя:', resp.status);
                        this.currentUser = null;
                    }
                } catch (error) {
                    console.warn('Ошибка при загрузке пользователя:', error);
                    this.currentUser = null;
                }
            },
            
            filteredDefects() {
                if (!this.defects || this.defects.length === 0) {
                    return [];
                }
                
                const term = this.searchTerm.toLowerCase();
                return this.defects.filter(d =>
                    (d.product && d.product.name ? d.product.name : '').toLowerCase().includes(term) ||
                    (d.user && d.user.full_name ? d.user.full_name : '').toLowerCase().includes(term)
                );
            },
            
            formatDate(dateStr) {
                if (!dateStr) return 'Дата не указана';
                try {
                const d = new Date(dateStr);
                    if (isNaN(d.getTime())) return 'Неверная дата';
                return d.toLocaleString('ru-RU');
                } catch (error) {
                    return 'Ошибка даты';
                }
            },
            
            getStatusClass(status) {
                if (!status) return 'bg-gray-100 text-gray-800';
                
                const classes = {
                    'pending': 'bg-yellow-100 text-yellow-800',
                    'confirmed': 'bg-blue-100 text-blue-800',
                    'repairable': 'bg-green-100 text-green-800',
                    'irreparable': 'bg-red-100 text-red-800',
                    'transferred': 'bg-purple-100 text-purple-800',
                    'repaired': 'bg-green-100 text-green-800',
                    'closed': 'bg-gray-100 text-gray-800'
                };
                return classes[status] || 'bg-gray-100 text-gray-800';
            },
            
            getDefectTypeClass(type) {
                if (!type) return 'bg-gray-100 text-gray-800';
                
                const classes = {
                    'technical': 'bg-blue-100 text-blue-800',
                    'manual': 'bg-red-100 text-red-800'
                };
                return classes[type] || 'bg-gray-100 text-gray-800';
            },
            
            canConfirmDefect(defect) {
                if (!this.currentUser || !defect) return false;
                if (this.currentUser.role !== 'master') return false;
                return defect.status === 'pending';
            },
            
            canMarkRepaired(defect) {
                if (!this.currentUser || !defect) return false;
                return defect.status === 'repairable' || defect.status === 'transferred';
            },
            
            canCloseDefect(defect) {
                if (!this.currentUser || !defect) return false;
                const adminRoles = ['founder', 'director', 'admin', 'master'];
                return adminRoles.includes(this.currentUser.role) && defect.status === 'repaired';
            },
            
            openConfirmationModal(defect) {
                console.log('openConfirmationModal вызвана с:', defect);
                if (!defect) return;
                this.selectedDefect = { ...defect };
                this.confirmationStep = 1;
                this.showConfirmationModal = true;
                this.showRepairModal = false; // Закрываем другое модальное окно
                console.log('Модальное окно открыто, selectedDefect:', this.selectedDefect);
            },
            
            openRepairModal(defect) {
                if (!defect) return;
                this.selectedDefect = defect;
                this.repairComment = '';
                this.showRepairModal = true;
                this.showConfirmationModal = false; // Закрываем другое модальное окно
            },
            
            closeConfirmationModal() {
                this.showConfirmationModal = false;
                this.confirmationStep = 1;
                this.selectedDefect = {};
            },
            
            closeRepairModal() {
                this.showRepairModal = false;
                this.repairComment = '';
                this.selectedDefect = {};
            },
            
            async confirmDefect() {
                console.log('confirmDefect вызвана', this.selectedDefect);
                
                if (!this.selectedDefect || !this.selectedDefect.id) {
                    console.error('Брак не выбран:', this.selectedDefect);
                    this.showNotification('Ошибка: брак не выбран', 'error');
                    return;
                }
                
                const csrfToken = this.getCSRFToken();
                console.log('CSRF токен:', csrfToken);
                
                if (!csrfToken) {
                    console.error('CSRF токен не найден');
                    this.showNotification('Ошибка: CSRF токен не найден. Обновите страницу.', 'error');
                    return;
                }
                
                const requestBody = {
                    is_repairable: this.selectedDefect.is_repairable,
                    defect_type: this.selectedDefect.defect_type,
                    target_workshop_id: this.selectedDefect.target_workshop_id,
                    comment: this.selectedDefect.comment || ''
                };
                
                console.log('Отправляем запрос:', requestBody);
                
                try {
                    const response = await fetch(`/defects/api/defects/${this.selectedDefect.id}/confirm/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    console.log('Ответ получен:', response.status, response.statusText);
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('Успешный ответ:', result);
                        this.closeConfirmationModal();
                        await this.fetchDefects();
                        this.showNotification('Брак успешно подтвержден', 'success');
                    } else {
                        const errorText = await response.text();
                        console.error('Ошибка ответа:', response.status, errorText);
                        let errorMessage = 'Ошибка при подтверждении брака';
                        
                        try {
                            const errorData = JSON.parse(errorText);
                            errorMessage = errorData.error || errorData.message || errorMessage;
                        } catch (e) {
                            errorMessage = `Ошибка ${response.status}: ${errorText}`;
                        }
                        
                        this.showNotification(errorMessage, 'error');
                    }
                } catch (error) {
                    console.error('Ошибка при выполнении запроса:', error);
                    this.showNotification(`Ошибка при подтверждении брака: ${error.message}`, 'error');
                }
            },
            
            async markAsRepaired() {
                if (!this.selectedDefect || !this.selectedDefect.id) {
                    this.showNotification('Ошибка: брак не выбран', 'error');
                    return;
                }
                
                try {
                    const response = await fetch(`/defects/api/defects/${this.selectedDefect.id}/mark_repaired/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': this.getCSRFToken()
                        },
                        body: JSON.stringify({
                            comment: this.repairComment
                        })
                    });
                    
                    if (response.ok) {
                        this.closeRepairModal();
                        await this.fetchDefects();
                        this.showNotification('Брак отмечен как починенный', 'success');
                    } else {
                        const error = await response.json();
                        this.showNotification(error.error || 'Ошибка при отметке брака', 'error');
                    }
                } catch (error) {
                    this.showNotification('Ошибка при отметке брака', 'error');
                }
            },
            
            async closeDefect() {
                if (!this.selectedDefect || !this.selectedDefect.id) {
                    this.showNotification('Ошибка: брак не выбран', 'error');
                    return;
                }
                
                if (!confirm('Вы уверены, что хотите закрыть этот брак?')) return;
                
                try {
                    const response = await fetch(`/defects/api/defects/${this.selectedDefect.id}/close/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': this.getCSRFToken()
                        }
                    });
                    
                    if (response.ok) {
                        await this.fetchDefects();
                        this.showNotification('Брак закрыт', 'success');
                    } else {
                        const error = await response.json();
                        this.showNotification(error.error || 'Ошибка при закрытии брака', 'error');
                    }
                } catch (error) {
                    this.showNotification('Ошибка при закрытии брака', 'error');
                }
            },
            
            getCSRFToken() {
                // Сначала пытаемся получить из meta тега
                const metaToken = document.querySelector('meta[name="csrf-token"]');
                if (metaToken) {
                    console.log('CSRF токен найден в meta теге');
                    return metaToken.getAttribute('content');
                }
                
                // Затем из cookie
                const name = 'csrftoken';
                let cookieValue = null;
                if (document.cookie && document.cookie !== '') {
                    const cookies = document.cookie.split(';');
                    for (let i = 0; i < cookies.length; i++) {
                        const cookie = cookies[i].trim();
                        if (cookie.substring(0, name.length + 1) === (name + '=')) {
                            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                            break;
                        }
                    }
                }
                
                if (cookieValue) {
                    console.log('CSRF токен найден в cookie');
                    return cookieValue;
                }
                
                // Если ничего не найдено, попробуем получить из Django формы
                const csrfInput = document.querySelector('input[name="csrfmiddlewaretoken"]');
                if (csrfInput) {
                    console.log('CSRF токен найден в форме');
                    return csrfInput.value;
                }
                
                console.warn('CSRF токен не найден нигде');
                return null;
            },
            
            showNotification(message, type) {
                alert(message);
            },
            
            async init() {
                try {
                    // Явно устанавливаем модальные окна в скрытое состояние
                    this.showConfirmationModal = false;
                    this.showRepairModal = false;
                    this.confirmationStep = 1;
                    this.selectedDefect = {};
                    this.repairComment = '';
                    
                    await Promise.all([
                        this.fetchDefects(),
                        this.fetchWorkshops(),
                        this.fetchCurrentUser()
                    ]);
                    this.$nextTick(() => {
                        try {
                            lucide.createIcons();
                        } catch (error) {
                            console.warn('Ошибка при создании иконок:', error);
                        }
                    });
                } catch (error) {
                    console.error('Ошибка при инициализации:', error);
                }
            },
            
            stats() {
                if (!this.defects || this.defects.length === 0) {
                    return {
                        totalDefects: 0,
                        pendingConfirmation: 0,
                        repairable: 0,
                        repaired: 0
                    };
                }
                
                const totalDefects = this.defects.length;
                const pendingConfirmation = this.defects.filter(d => d.status === 'pending').length;
                const repairable = this.defects.filter(d => d.status === 'repairable').length;
                const repaired = this.defects.filter(d => d.status === 'repaired').length;
                
                return { 
                    totalDefects, 
                    pendingConfirmation, 
                    repairable, 
                    repaired
                };
            }
        }
    }
    
    document.addEventListener('alpine:init', () => {
        Alpine.data('defectsData', defectsData);
    });
    </script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            lucide.createIcons();
        });
    </script>
</body>
</html> 